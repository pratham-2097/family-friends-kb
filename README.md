This project is a compact “Family & Friends” knowledge base in Prolog that puts the logic-programming part of the course into practice. Instead of telling the computer how to compute an answer step by step, the program declares facts about a small world and rules that are true in that world; Prolog’s engine then uses unification and backtracking to discover answers that satisfy those declarations. That shift—from procedures to declarations—is the core difference between imperative and logic programming, and it’s exactly what this project demonstrates.

The data layer is a set of ground facts (atoms): who is male or female, who is married to whom, and parent–child relationships. In Prolog, these are written with lowercase identifiers like male(vivek). or parent(vivek, pratham). Lowercase symbols are atoms; uppercase identifiers are variables. This syntax mirrors the first-order predicate calculus the paradigm is based on: predicates (like parent/2) applied to terms (like vivek, pratham) express facts, while variables let the engine search for bindings that make goals true.

On top of the facts, the program defines intensional knowledge—rules that derive new relationships. For instance, spouse/2 is defined symmetrically from married/2 with two alternatives joined by disjunction ;, so either direction counts as a spouse. mother/2 and father/2 are constraints over parent/2 and gender. sibling/2 is a classic relational join over shared parents, with a disequality guard X \= Y so a person isn’t considered their own sibling. These are examples of rules having both a declarative reading (“X and Y are siblings if there exists a parent P who is a parent of both, and X is not Y”) and a procedural reading (what the engine will try first, second, etc.). The declarative reading is the one we care about when explaining correctness.

The most important rule for showing recursion is ancestor/2. It has a base clause (“a parent is an ancestor”) and an inductive clause (“a parent of an ancestor is also an ancestor”). This is the same recursive shape as the transitive closure you see throughout CS, and it mirrors how recursive definitions are introduced in class: a base case and a recursive case. When you query ancestor(A, pratham), unification binds A to values that satisfy either the base clause or, through backtracking, the recursive chain parent(A, Y), ancestor(Y, pratham). This is where Prolog’s search really matters. Each time there are multiple ways to satisfy a subgoal (e.g., multiple parents or multiple paths up the tree), Prolog creates a choice point. If a later goal fails, it backtracks to the most recent choice point and tries the next alternative. That exact mechanism is what makes queries like “list all ancestors” or “list all cousins” work without us writing any loops.

cousin/2 shows same-generation inference: X and Y are cousins if their parents are siblings and X ≠ Y. This ties together three layers of knowledge—parent/2, sibling/2, and the inequality guard—showing how rules compose. sibling_in_law/2 then introduces an either-or rule: you can be someone’s sibling-in-law either by being the sibling of their spouse or the spouse of their sibling. This rule also demonstrates how Prolog’s search explores both branches (joined with ;) and returns all values that make the head true.

To query and present results, the project uses two collection patterns that came up in class: setof/3 and findall/3 followed by sort/2. setof(Var, Goal, Set) asks Prolog to find all distinct bindings of Var that satisfy Goal, then returns them as a sorted, duplicate-free list. It’s perfect for crisp, deterministic outputs like “all siblings of Pratham,” “all cousins,” “all ancestors,” and “all siblings-in-law.” One subtlety with setof is existential variables. If a goal contains variables besides the one you’re collecting, Prolog groups results by those variables. In our good_match/3 predicate (explained below), the hidden interest Thing would cause grouping unless we either existentially quantify it with T^ inside setof or avoid grouping entirely by using findall(Y, …, Bag) and then sort(Bag, Recs). The code shows the second pattern for recommendations, and the first pattern is an equally correct alternative; both are straight from the course toolkit.

The small recommender is where several course ideas meet. good_match(X, Y, Thing) says that X and Y are a potential match if they both like the same Thing, they aren’t the same person, they aren’t already friends, and they aren’t related. The “not friends” and “not related” parts use negation-as-failure (\+). In Prolog, \+ Goal succeeds exactly when Goal cannot be proven from the current knowledge base. That’s the closed-world assumption in action: anything not derivable is treated as false. Our related/2 helper collects many ways people can be related—parent/child, siblings, spouses, and the recursive ancestors/descendants—so the recommender doesn’t suggest family members. That change was motivated by a real test where Vivek (a parent) incorrectly appeared among recommendations until we strengthened the “not related” constraint. That debugging step is a nice example of using the declarative model and the course’s emphasis on precise predicates to make the program reflect intent.

A few other Prolog idioms are visible in the final code:

Symmetry via rules rather than duplicate facts: spouse/2 is derived from married/2 in both directions, so we keep the data normalized.

Recursive definitions with a clear base case: ancestor/2 stops at a direct parent; without that base, a query would not terminate.

Guards to avoid self-relations: X \= Y appears in sibling/2 and cousin/2.

Deterministic presentation: setof/3 sorts and deduplicates results, giving stable output for demonstrations and tests.

It’s also worth noticing what the project does not use and why. We didn’t need cuts (!). Cuts are powerful for pruning search (green cuts) or enforcing a procedural strategy (red cuts), as shown in class with merge/3 and the bubble-sort example, but our predicates are written so that the first successful path naturally produces all correct answers without leaving behind useless choice points. That keeps the program purely declarative and easy to reason about. We also didn’t rely on list-processing idioms like append/3, prefix/2, or permutation/2 here, because our domain is people, not lists. If we extended the project to, say, generate all possible sibling groups or insert a person into a sorted roster, those classic list predicates would be a natural addition.

The program shows how recursion replaces loops in a language without mutable state. You can see the same philosophy in the course’s functional-programming unit: structural recursion, pattern matching, and the use of higher-order folds prevent side effects and make programs easier to reason about. While this project is not written in Haskell, the spirit is similar—relationships are defined by equations, not by stepwise updates, and the engine takes care of evaluation order. On the evaluation side, Prolog is nondeterministic but precise: it tries to satisfy the leftmost goal first, creates a choice point if multiple clauses could match, and backtracks only on failure. That model lines up with the glossary definition of backtracking from class and is observable by running the sample queries and, if desired, tracing.

From the “describing vs recognizing” perspective in the grammars unit, you can think of each predicate as a recognizer: sibling(X, Y) recognizes exactly those pairs of names that belong to the language of sibling pairs generated by the base facts and rules. The difference is that our “grammar” is a set of Prolog clauses and our “parser” is the Prolog engine; both viewpoints emphasize that a formal description plus a recognizer lets us decide membership without enumerating all valid strings (or in this case, all valid relationships).

Finally, the project applies the declarative paradigm substantively; it demonstrates how language design choices (facts, rules, unification, backtracking, negation-as-failure, recursion) shape both the program’s structure and how problems are solved; and it is a complete, self-contained artifact that runs in SWI-Prolog with a single command. The run_demo/0 predicate provides a reproducible set of queries that exercise the main ideas: computing siblings, cousins, transitive ancestors, in-law relationships, and interest-based recommendations under constraints. The dataset is personalized to make the outputs meaningful, but the rules are general. If you add more facts—new marriages, new friendships, new likes—the same rules continue to work, which is exactly the payoff of writing declarative, compositional predicates.

In short, this code turns the key concepts from the notes into a working system: predicates as facts and rules, variable binding by unification, search via choice points and backtracking, recursion for transitive properties, negation-as-failure for constraints, and solution collection with setof or findall and sort. It’s small, but it exercises the core of logic programming
